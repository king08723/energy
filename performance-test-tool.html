<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è®¾å¤‡é¡µé¢æ€§èƒ½æµ‹è¯•å·¥å…·</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #2d3748;
        }

        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(248, 250, 252, 0.8);
            border-radius: 10px;
            border-left: 4px solid #3b82f6;
        }

        .test-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .test-button {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .test-button.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        .test-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(229, 231, 235, 0.8);
        }

        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 14px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .performance-chart {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .log-container {
            background: #1f2937;
            color: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 4px;
        }

        .log-entry.info {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
        }

        .log-entry.warning {
            background: rgba(245, 158, 11, 0.1);
            border-left: 3px solid #f59e0b;
        }

        .log-entry.error {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }

        .log-entry.success {
            background: rgba(16, 185, 129, 0.1);
            border-left: 3px solid #10b981;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            width: 0%;
            transition: width 0.3s ease;
        }

        .device-list {
            max-height: 300px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            padding: 15px;
        }

        .device-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #e5e7eb;
            transition: background 0.2s ease;
        }

        .device-item:hover {
            background: #f8fafc;
        }

        .device-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .device-status.online {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
        }

        .device-status.offline {
            background: rgba(156, 163, 175, 0.1);
            color: #6b7280;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            transition: border-color 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .filter-tags {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-tag {
            padding: 8px 16px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .filter-tag.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .filter-tag:hover {
            background: #e5e7eb;
        }

        .filter-tag.active:hover {
            background: #2563eb;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ è®¾å¤‡é¡µé¢æ€§èƒ½æµ‹è¯•å·¥å…·</h1>
            <p>æ¨¡æ‹ŸWeChat Mini Programè®¾å¤‡ç®¡ç†é¡µé¢çš„æ€§èƒ½æµ‹è¯•å’Œç›‘æ§</p>
        </div>

        <!-- æ€§èƒ½æŒ‡æ ‡ -->
        <div class="test-section">
            <h3>ğŸ“Š å®æ—¶æ€§èƒ½æŒ‡æ ‡</h3>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="searchCount">0</div>
                    <div class="metric-label">æœç´¢æ¬¡æ•°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="filterCount">0</div>
                    <div class="metric-label">ç­›é€‰æ¬¡æ•°</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="setDataCount">0</div>
                    <div class="metric-label">setDataè°ƒç”¨</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="memoryUsage">0MB</div>
                    <div class="metric-label">å†…å­˜ä½¿ç”¨</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="avgResponseTime">0ms</div>
                    <div class="metric-label">å¹³å‡å“åº”æ—¶é—´</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="cacheHitRate">0%</div>
                    <div class="metric-label">ç¼“å­˜å‘½ä¸­ç‡</div>
                </div>
            </div>
        </div>

        <!-- æµ‹è¯•æ§åˆ¶ -->
        <div class="test-section">
            <h3>ğŸ§ª æ€§èƒ½æµ‹è¯•æ§åˆ¶</h3>
            <div class="test-controls">
                <button class="test-button" onclick="startStressTest()">å‹åŠ›æµ‹è¯•</button>
                <button class="test-button" onclick="startMemoryLeakTest()">å†…å­˜æ³„æ¼æµ‹è¯•</button>
                <button class="test-button" onclick="startRealTimeTest()">å®æ—¶æ›´æ–°æµ‹è¯•</button>
                <button class="test-button success" onclick="generateLargeDataset()">ç”Ÿæˆå¤§æ•°æ®é›†</button>
                <button class="test-button danger" onclick="clearAllData()">æ¸…ç©ºæ•°æ®</button>
                <button class="test-button" onclick="exportPerformanceReport()">å¯¼å‡ºæŠ¥å‘Š</button>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="testProgress"></div>
            </div>
        </div>

        <!-- æœç´¢å’Œç­›é€‰æµ‹è¯• -->
        <div class="test-section">
            <h3>ğŸ” æœç´¢å’Œç­›é€‰æµ‹è¯•</h3>
            <input type="text" class="search-input" id="searchInput" placeholder="è¾“å…¥æœç´¢å…³é”®è¯..."
                oninput="onSearchInput(event)">
            <div class="filter-tags">
                <span class="filter-tag active" data-type="all" onclick="onFilterType(event)">å…¨éƒ¨</span>
                <span class="filter-tag" data-type="meter" onclick="onFilterType(event)">ç”µè¡¨</span>
                <span class="filter-tag" data-type="sensor" onclick="onFilterType(event)">ä¼ æ„Ÿå™¨</span>
                <span class="filter-tag" data-type="switch" onclick="onFilterType(event)">å¼€å…³</span>
                <span class="filter-tag" data-type="offline" onclick="onFilterType(event)">ç¦»çº¿è®¾å¤‡</span>
                <span class="filter-tag" data-type="alert" onclick="onFilterType(event)">å‘Šè­¦è®¾å¤‡</span>
            </div>
            <div class="device-list" id="deviceList"></div>
        </div>

        <!-- æ€§èƒ½æ—¥å¿— -->
        <div class="test-section">
            <h3>ğŸ“ æ€§èƒ½æ—¥å¿—</h3>
            <div class="log-container" id="performanceLog"></div>
        </div>
    </div>

    <script>
        // æ€§èƒ½ç›‘æ§å¯¹è±¡
        const performanceMonitor = {
            searchCount: 0,
            filterCount: 0,
            setDataCount: 0,
            memoryUsage: 0,
            responseTimes: [],
            cacheHits: 0,
            cacheMisses: 0,
            startTime: Date.now()
        };

        // æ¨¡æ‹Ÿè®¾å¤‡æ•°æ®
        let allDevices = [];
        let filteredDevices = [];
        let searchKeyword = '';
        let filterType = 'all';
        let searchTimer = null;
        let isSearching = false;

        // æ•°æ®ç¼“å­˜
        const dataCache = {
            lastFilterResult: null,
            lastFilterParams: null,
            deviceLookup: new Map()
        };

        // ç”Ÿæˆæµ‹è¯•æ•°æ®
        function generateTestData(count) {
            allDevices = [];
            const deviceTypes = ['meter', 'sensor', 'switch', 'hvac'];
            const locations = ['ç”Ÿäº§è½¦é—´AåŒº', 'åŠå…¬æ¥¼2å±‚', 'ä»“åº“', 'é…ç”µæˆ¿', 'å±‹é¡¶', 'åœ°ä¸‹å®¤'];

            for (let i = 0; i < count; i++) {
                const type = deviceTypes[Math.floor(Math.random() * deviceTypes.length)];
                const location = locations[Math.floor(Math.random() * locations.length)];
                const status = Math.random() > 0.2 ? 'online' : 'offline';
                const hasAlert = Math.random() > 0.8;

                allDevices.push({
                    id: `device_${String(i + 1).padStart(3, '0')}`,
                    name: `${type === 'meter' ? 'ç”µè¡¨' : type === 'sensor' ? 'ä¼ æ„Ÿå™¨' : type === 'switch' ? 'å¼€å…³' : 'ç©ºè°ƒ'}${i + 1}`,
                    location: location,
                    type: type,
                    status: status,
                    statusText: status === 'online' ? 'åœ¨çº¿' : 'ç¦»çº¿',
                    hasAlert: hasAlert,
                    alerts: hasAlert ? [{ severity: 'warning', message: 'è®¾å¤‡å¼‚å¸¸' }] : [],
                    power: Math.random() * 1000,
                    energy: Math.random() * 10000,
                    lastUpdate: Date.now()
                });
            }

            filteredDevices = [...allDevices];
            renderDevices();
            logMessage(`ç”Ÿæˆäº† ${count} ä¸ªæµ‹è¯•è®¾å¤‡`, 'success');
        }

        // æ¸²æŸ“è®¾å¤‡åˆ—è¡¨
        function renderDevices() {
            const deviceList = document.getElementById('deviceList');
            deviceList.innerHTML = '';

            const displayDevices = filteredDevices.slice(0, 50); // åªæ˜¾ç¤ºå‰50ä¸ª

            displayDevices.forEach(device => {
                const deviceItem = document.createElement('div');
                deviceItem.className = 'device-item';
                deviceItem.innerHTML = `
                    <div>
                        <strong>${device.name}</strong>
                        <div style="font-size: 12px; color: #6b7280;">${device.location}</div>
                    </div>
                    <div class="device-status ${device.status}">
                        ${device.statusText}
                        ${device.hasAlert ? ' âš ï¸' : ''}
                    </div>
                `;
                deviceList.appendChild(deviceItem);
            });
        }

        // ä¼˜åŒ–çš„æœç´¢å’Œç­›é€‰é€»è¾‘ï¼ˆå¤åˆ¶è‡ªä¿®å¤åçš„ä»£ç ï¼‰
        function applyFilters() {
            const startTime = Date.now();
            performanceMonitor.filterCount++;

            // æ£€æŸ¥ç¼“å­˜
            const filterParams = {
                searchKeyword: searchKeyword || '',
                filterType: filterType || 'all',
                deviceCount: allDevices.length
            };

            const cacheKey = JSON.stringify(filterParams);
            if (dataCache.lastFilterParams === cacheKey && dataCache.lastFilterResult) {
                filteredDevices = dataCache.lastFilterResult;
                performanceMonitor.cacheHits++;
                renderDevices();

                const duration = Date.now() - startTime;
                performanceMonitor.responseTimes.push(duration);
                logMessage(`ç­›é€‰å®Œæˆï¼ˆç¼“å­˜å‘½ä¸­ï¼‰ï¼Œè€—æ—¶: ${duration}ms`, 'success');
                updateMetrics();
                return;
            }

            performanceMonitor.cacheMisses++;
            let filtered = allDevices;

            // æœç´¢è¿‡æ»¤
            if (searchKeyword && searchKeyword.trim()) {
                performanceMonitor.searchCount++;
                const keyword = searchKeyword.trim();
                const isChineseKeyword = /[\u4e00-\u9fa5]/.test(keyword);

                const searchCondition = isChineseKeyword ?
                    (text) => text.includes(keyword) :
                    (text) => text.toLowerCase().includes(keyword.toLowerCase());

                filtered = filtered.filter(device => {
                    const deviceName = (device.name || '').toString();
                    const deviceLocation = (device.location || '').toString();
                    const deviceType = (device.type || '').toString();
                    const deviceId = (device.id || '').toString();

                    return searchCondition(deviceName) ||
                        searchCondition(deviceLocation) ||
                        searchCondition(deviceType) ||
                        searchCondition(deviceId);
                });
            }

            // ç±»å‹ç­›é€‰
            if (filterType !== 'all') {
                if (filterType === 'offline') {
                    filtered = filtered.filter(device => device.status === 'offline');
                } else if (filterType === 'alert') {
                    filtered = filtered.filter(device => device.hasAlert);
                } else {
                    filtered = filtered.filter(device => device.type === filterType);
                }
            }

            // ç¼“å­˜ç»“æœ
            dataCache.lastFilterResult = filtered;
            dataCache.lastFilterParams = cacheKey;

            filteredDevices = filtered;
            renderDevices();

            const duration = Date.now() - startTime;
            performanceMonitor.responseTimes.push(duration);
            performanceMonitor.setDataCount++;

            logMessage(`ç­›é€‰å®Œæˆï¼Œç»“æœ: ${filtered.length}/${allDevices.length}ï¼Œè€—æ—¶: ${duration}ms`, 'info');
            updateMetrics();
        }

        // æœç´¢è¾“å…¥å¤„ç†
        function onSearchInput(event) {
            const newKeyword = event.target.value;
            if (searchKeyword === newKeyword) {
                return;
            }

            searchKeyword = newKeyword;
            debounceSearch();
        }

        // é˜²æŠ–æœç´¢
        function debounceSearch() {
            if (searchTimer) {
                clearTimeout(searchTimer);
            }

            isSearching = true;
            searchTimer = setTimeout(() => {
                if (isSearching) {
                    applyFilters();
                    isSearching = false;
                }
            }, 300);
        }

        // ç­›é€‰ç±»å‹å¤„ç†
        function onFilterType(event) {
            filterType = event.target.dataset.type;

            document.querySelectorAll('.filter-tag').forEach(tag => {
                tag.classList.remove('active');
            });
            event.target.classList.add('active');

            applyFilters();
        }

        // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
        function updateMetrics() {
            document.getElementById('searchCount').textContent = performanceMonitor.searchCount;
            document.getElementById('filterCount').textContent = performanceMonitor.filterCount;
            document.getElementById('setDataCount').textContent = performanceMonitor.setDataCount;

            // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨
            const memoryUsage = (performanceMonitor.setDataCount * 0.1 + allDevices.length * 0.01).toFixed(1);
            document.getElementById('memoryUsage').textContent = memoryUsage + 'MB';

            // å¹³å‡å“åº”æ—¶é—´
            const avgTime = performanceMonitor.responseTimes.length > 0 ?
                (performanceMonitor.responseTimes.reduce((a, b) => a + b, 0) / performanceMonitor.responseTimes.length).toFixed(1) : 0;
            document.getElementById('avgResponseTime').textContent = avgTime + 'ms';

            // ç¼“å­˜å‘½ä¸­ç‡
            const totalRequests = performanceMonitor.cacheHits + performanceMonitor.cacheMisses;
            const hitRate = totalRequests > 0 ? ((performanceMonitor.cacheHits / totalRequests) * 100).toFixed(1) : 0;
            document.getElementById('cacheHitRate').textContent = hitRate + '%';
        }

        // æ—¥å¿—è®°å½•
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('performanceLog');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // å‹åŠ›æµ‹è¯•
        function startStressTest() {
            logMessage('å¼€å§‹å‹åŠ›æµ‹è¯•...', 'warning');
            const testKeywords = ['ç”µè¡¨', 'ä¼ æ„Ÿå™¨', 'å¼€å…³', 'ç©ºè°ƒ', 'è½¦é—´', 'åŠå…¬', 'ä»“åº“', 'device', 'sensor', 'meter'];
            let testIndex = 0;

            const stressInterval = setInterval(() => {
                if (testIndex >= 100) {
                    clearInterval(stressInterval);
                    logMessage('å‹åŠ›æµ‹è¯•å®Œæˆ', 'success');
                    updateProgress(100);
                    return;
                }

                // éšæœºæœç´¢
                const keyword = testKeywords[Math.floor(Math.random() * testKeywords.length)];
                searchKeyword = keyword;
                document.getElementById('searchInput').value = keyword;

                // éšæœºç­›é€‰
                const filters = ['all', 'meter', 'sensor', 'switch', 'offline', 'alert'];
                filterType = filters[Math.floor(Math.random() * filters.length)];

                applyFilters();
                testIndex++;
                updateProgress((testIndex / 100) * 100);
            }, 50);
        }

        // å†…å­˜æ³„æ¼æµ‹è¯•
        function startMemoryLeakTest() {
            logMessage('å¼€å§‹å†…å­˜æ³„æ¼æµ‹è¯•...', 'warning');
            let testCount = 0;

            const memoryInterval = setInterval(() => {
                if (testCount >= 50) {
                    clearInterval(memoryInterval);
                    logMessage('å†…å­˜æ³„æ¼æµ‹è¯•å®Œæˆ', 'success');
                    updateProgress(100);
                    return;
                }

                // åˆ›å»ºå¤§é‡ä¸´æ—¶æ•°æ®
                const tempDevices = [];
                for (let i = 0; i < 1000; i++) {
                    tempDevices.push({
                        id: `temp_${i}`,
                        name: `ä¸´æ—¶è®¾å¤‡${i}`,
                        data: new Array(1000).fill(Math.random())
                    });
                }

                // æ¨¡æ‹ŸsetDataè°ƒç”¨
                performanceMonitor.setDataCount += 10;

                testCount++;
                updateProgress((testCount / 50) * 100);
                updateMetrics();
            }, 100);
        }

        // å®æ—¶æ›´æ–°æµ‹è¯•
        function startRealTimeTest() {
            logMessage('å¼€å§‹å®æ—¶æ›´æ–°æµ‹è¯•...', 'warning');
            let updateCount = 0;

            const realTimeInterval = setInterval(() => {
                if (updateCount >= 100) {
                    clearInterval(realTimeInterval);
                    logMessage('å®æ—¶æ›´æ–°æµ‹è¯•å®Œæˆ', 'success');
                    updateProgress(100);
                    return;
                }

                // éšæœºæ›´æ–°è®¾å¤‡çŠ¶æ€
                const randomDevice = allDevices[Math.floor(Math.random() * allDevices.length)];
                if (randomDevice) {
                    randomDevice.status = Math.random() > 0.5 ? 'online' : 'offline';
                    randomDevice.statusText = randomDevice.status === 'online' ? 'åœ¨çº¿' : 'ç¦»çº¿';
                    randomDevice.power = Math.random() * 1000;

                    // æ¨¡æ‹Ÿå®æ—¶æ›´æ–°
                    performanceMonitor.setDataCount++;
                    renderDevices();
                }

                updateCount++;
                updateProgress((updateCount / 100) * 100);
                updateMetrics();
            }, 200);
        }

        // ç”Ÿæˆå¤§æ•°æ®é›†
        function generateLargeDataset() {
            const count = parseInt(prompt('è¯·è¾“å…¥è®¾å¤‡æ•°é‡ï¼ˆå»ºè®®1000-5000ï¼‰:', '1000'));
            if (count && count > 0) {
                generateTestData(count);
                logMessage(`ç”Ÿæˆäº† ${count} ä¸ªè®¾å¤‡çš„å¤§æ•°æ®é›†`, 'success');
            }
        }

        // æ¸…ç©ºæ•°æ®
        function clearAllData() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿ')) {
                allDevices = [];
                filteredDevices = [];
                dataCache.lastFilterResult = null;
                dataCache.lastFilterParams = null;
                dataCache.deviceLookup.clear();

                // é‡ç½®æ€§èƒ½ç›‘æ§
                Object.keys(performanceMonitor).forEach(key => {
                    if (typeof performanceMonitor[key] === 'number') {
                        performanceMonitor[key] = 0;
                    } else if (Array.isArray(performanceMonitor[key])) {
                        performanceMonitor[key] = [];
                    }
                });

                renderDevices();
                updateMetrics();
                logMessage('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º', 'warning');
            }
        }

        // å¯¼å‡ºæ€§èƒ½æŠ¥å‘Š
        function exportPerformanceReport() {
            const report = {
                timestamp: new Date().toISOString(),
                deviceCount: allDevices.length,
                performanceMetrics: performanceMonitor,
                cacheStats: {
                    hits: performanceMonitor.cacheHits,
                    misses: performanceMonitor.cacheMisses,
                    hitRate: performanceMonitor.cacheHits / (performanceMonitor.cacheHits + performanceMonitor.cacheMisses) * 100
                }
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `performance-report-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            logMessage('æ€§èƒ½æŠ¥å‘Šå·²å¯¼å‡º', 'success');
        }

        // æ›´æ–°è¿›åº¦æ¡
        function updateProgress(percentage) {
            document.getElementById('testProgress').style.width = percentage + '%';
        }

        // åˆå§‹åŒ–
        window.onload = function () {
            generateTestData(100);
            updateMetrics();
            logMessage('æ€§èƒ½æµ‹è¯•å·¥å…·å·²åˆå§‹åŒ–', 'info');
        };
    </script>
</body>

</html>